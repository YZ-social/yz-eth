<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>YZ-ETH Multisynq Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .card h3 {
            margin-top: 0;
            color: #333;
        }
        
        .stat {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #5a6fd8;
        }
        
        .transaction-form {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr auto;
            gap: 10px;
            align-items: end;
        }
        
        select, input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .activity {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .activity-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 400px;
            overflow-y: auto;
        }
        
        .block-item, .transaction-item, .contract-item {
            background: #f8f9fa;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            font-size: 12px;
        }
        
        .status-bar {
            background: #333;
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .messages {
            margin-top: 10px;
        }
        
        .error-message {
            background: #ffe6e6;
            color: #d63031;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        .success-message {
            background: #e6ffe6;
            color: #00b894;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        .heartbeat {
            background: #2d3436;
            color: #00b894;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            margin-top: 10px;
        }
        
        .sync-monitor {
            text-align: right;
        }
        
        .heartbeat-counter {
            background: #e17055;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            min-width: 60px;
        }
        
        .model-hash {
            background: #6c5ce7;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>‚≠ê YZ-ETH Blockchain Simulator</h1>
        <p>Powered by Multisynq Real-time Synchronization | Version 0.1.14</p>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div class="heartbeat" id="blockchainTick">Initializing...</div>
            <div class="sync-monitor">
                <div class="heartbeat-counter" id="heartbeatCounter">0</div>
                <div class="model-hash" id="modelHash">Hash: calculating...</div>
            </div>
        </div>
    </div>
    
    <!-- Dashboard -->
    <div class="dashboard">
        <div class="card">
            <h3>üì¶ Blocks</h3>
            <div class="stat" id="blockCount">0</div>
        </div>
        
        <div class="card">
            <h3>üìÑ Contracts</h3>
            <div class="stat" id="contractCount">0</div>
        </div>
        
        <div class="card">
            <h3>‚è∞ Pending Txs</h3>
            <div class="stat" id="pendingTransactions">0</div>
        </div>
    </div>
    
    <!-- Account Balances -->
    <div class="card">
        <h3>üí∞ Account Balances</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
            <div>Account 1: <span id="balance0">0 ETH</span></div>
            <div>Account 2: <span id="balance1">0 ETH</span></div>
            <div>Account 3: <span id="balance2">0 ETH</span></div>
        </div>
    </div>
    
    <!-- Controls -->
    <div class="controls">
        <h3>üéÆ Blockchain Controls</h3>
        
        <div class="button-group">
            <button id="createBlockBtn">‚õèÔ∏è Mine Block</button>
            <button id="deployContractBtn">üìù Deploy Test Contract</button>
        </div>
        
        <h4>üí∏ Send Transaction</h4>
        <div class="transaction-form">
            <select id="fromAccount">
                <option value="0x1234567890123456789012345678901234567890">Account 1</option>
                <option value="0x2345678901234567890123456789012345678901">Account 2</option>
                <option value="0x3456789012345678901234567890123456789012">Account 3</option>
            </select>
            
            <select id="toAccount">
                <option value="0x2345678901234567890123456789012345678901">Account 2</option>
                <option value="0x1234567890123456789012345678901234567890">Account 1</option>
                <option value="0x3456789012345678901234567890123456789012">Account 3</option>
            </select>
            
            <input type="number" id="transactionValue" placeholder="Amount (ETH)" value="10">
            
            <button id="sendTransactionBtn">üí∏ Send</button>
        </div>
        
        <h4>üìù Smart Contract Development</h4>
        <div class="contract-development">
            <textarea id="solidityCode" placeholder="Enter Solidity code here..." rows="8" style="width: 100%; font-family: monospace; margin-bottom: 10px;">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleStorage {
    uint256 public storedData;
    
    constructor(uint256 initialValue) {
        storedData = initialValue;
    }
    
    function set(uint256 x) public {
        storedData = x;
    }
    
    function get() public view returns (uint256) {
        return storedData;
    }
}</textarea>
            <div class="contract-controls">
                <input type="text" id="contractName" placeholder="Contract Name" value="SimpleStorage" style="margin-right: 10px;">
                <button id="compileContractBtn">üî® Compile Contract</button>
                <button id="deployCompiledBtn" disabled>üöÄ Deploy Compiled</button>
            </div>
            <div id="compilationStatus" style="margin-top: 10px; padding: 10px; border-radius: 5px; display: none;"></div>
        </div>
    </div>
    
    <!-- Activity Panels -->
    <div class="activity">
        <div class="activity-panel">
            <h3>üì¶ Recent Blocks</h3>
            <div id="blocksList"></div>
        </div>
        
        <div class="activity-panel">
            <h3>üí∏ Recent Transactions</h3>
            <div id="transactionsList"></div>
        </div>
        
        <div class="activity-panel">
            <h3>üìÑ Deployed Contracts</h3>
            <div id="contractsList"></div>
        </div>
    </div>
    
    <!-- Status Messages -->
    <div class="messages">
        <div id="errorMessages"></div>
        <div id="statusMessages"></div>
    </div>
    
    <!-- Include Multisynq (exactly like Hello World) -->
    <script src="https://cdn.jsdelivr.net/npm/@multisynq/client@latest"></script>
    
    <!-- Include CompilationManager -->
    <script src="./src/services/CompilationManager.js"></script>
    
    <script>
        // Load our BlockchainModel and BlockchainView
        // (In production, these would be separate files)
        
        // BlockchainModel code (from our model file)
        class BlockchainModel extends Multisynq.Model {
            init() {
                console.log("BlockchainModel: Initializing...");
                
                // Initialize blockchain state (like Hello World's count = 0)
                this.blocks = [];
                this.accounts = [
                    { address: "0x1234567890123456789012345678901234567890", balance: 1000n },
                    { address: "0x2345678901234567890123456789012345678901", balance: 1000n },
                    { address: "0x3456789012345678901234567890123456789012", balance: 1000n }
                ];
                this.contracts = [];
                this.currentBlockNumber = 0;
                this.pendingTransactions = [];
                this.heartbeatCount = 0;
                
                // Subscribe to blockchain events (like Hello World's counter reset)
                this.subscribe("blockchain", "createBlock", this.createBlock);
                this.subscribe("blockchain", "executeTransaction", this.executeTransaction);
                this.subscribe("blockchain", "deployContract", this.deployContract);
                this.subscribe("compilation", "complete", this.handleCompiledContract);
                
                // Note: Compilation is handled externally by CompilationManager
                // Results are published to the model via View
                
                // Create genesis block
                this.createGenesisBlock();
                
                // Start heartbeat counter (1 second intervals)
                this.future(1000).heartbeat();
                
                // Auto-mine blocks every 15 seconds (like Hello World's tick)
                this.future(15000).autoMineBlock();
                
                console.log("BlockchainModel: Initialized with genesis block");
            }
            
            createGenesisBlock() {
                const genesisBlock = {
                    number: 0,
                    transactions: [],
                    timestamp: this.now(), // Use Multisynq deterministic time
                    hash: "0x0000000000000000000000000000000000000000000000000000000000000000",
                    parentHash: "0x0000000000000000000000000000000000000000000000000000000000000000"
                };
                
                this.blocks.push(genesisBlock);
                this.publish("blockchain", "blockAdded", { 
                    block: genesisBlock,
                    isGenesis: true 
                });
            }
            
            createBlock() {
                console.log("BlockchainModel: Creating new block...");
                
                // Create new block (like Hello World's resetCounter)
                const newBlock = {
                    number: this.currentBlockNumber + 1,
                    transactions: [...this.pendingTransactions],
                    timestamp: this.now(), // Use Multisynq deterministic time
                    hash: this.generateBlockHash(),
                    parentHash: this.getLastBlock().hash
                };
                
                this.blocks.push(newBlock);
                this.currentBlockNumber++;
                this.pendingTransactions = []; // Clear pending transactions
                
                console.log(`BlockchainModel: Block ${newBlock.number} created with ${newBlock.transactions.length} transactions`);
                
                // Publish event (like Hello World's publish counter changed)
                this.publish("blockchain", "blockAdded", { 
                    block: newBlock,
                    totalBlocks: this.blocks.length 
                });
            }
            
            executeTransaction(transactionData) {
                console.log("BlockchainModel: Executing transaction...", transactionData);
                
                try {
                    // Simple transaction execution (transfer ETH)
                    const { from, to, value } = transactionData;
                    
                    // Find accounts
                    const fromAccount = this.accounts.find(acc => acc.address === from);
                    const toAccount = this.accounts.find(acc => acc.address === to);
                    
                    if (!fromAccount || !toAccount) {
                        throw new Error("Account not found");
                    }
                    
                    if (fromAccount.balance < BigInt(value)) {
                        throw new Error("Insufficient balance");
                    }
                    
                    // Execute transfer
                    fromAccount.balance -= BigInt(value);
                    toAccount.balance += BigInt(value);
                    
                    // Create transaction record
                    const transaction = {
                        hash: this.generateTransactionHash(),
                        from,
                        to,
                        value,
                        status: "success",
                        timestamp: this.now() // Use Multisynq deterministic time
                    };
                    
                    // Add to pending transactions
                    this.pendingTransactions.push(transaction);
                    
                    console.log("BlockchainModel: Transaction executed successfully");
                    
                    // Publish transaction executed event
                    this.publish("blockchain", "transactionExecuted", { 
                        transaction,
                        fromBalance: fromAccount.balance.toString(),
                        toBalance: toAccount.balance.toString()
                    });
                    
                } catch (error) {
                    console.error("BlockchainModel: Transaction failed:", error.message);
                    
                    this.publish("blockchain", "transactionFailed", { 
                        error: error.message,
                        transactionData 
                    });
                }
            }
            
            deployContract(contractData) {
                console.log("BlockchainModel: Deploying contract...", contractData);
                
                try {
                    const { bytecode, abi, contractName, from } = contractData;
                    
                    // Validate deployment data
                    if (!bytecode || !contractName || !from) {
                        throw new Error("Missing required deployment data: bytecode, contractName, or from address");
                    }
                    
                    // Generate contract address
                    const contractAddress = this.generateContractAddress();
                    
                    // Create contract instance
                    const contract = {
                        address: contractAddress,
                        name: contractName,
                        bytecode,
                        abi: abi || [],
                        deployedBy: from,
                        deployedAt: this.now(), // Use Multisynq deterministic time
                        isCompiled: bytecode.length > 100 // Distinguish compiled vs test contracts
                    };
                    
                    this.contracts.push(contract);
                    
                    // Create deployment transaction
                    const transaction = {
                        hash: this.generateTransactionHash(),
                        from,
                        to: contractAddress,
                        value: "0",
                        data: bytecode.substring(0, 50) + "...", // Truncate for display
                        status: "success",
                        type: "contract_deployment",
                        timestamp: this.now() // Use Multisynq deterministic time
                    };
                    
                    this.pendingTransactions.push(transaction);
                    
                    console.log(`BlockchainModel: Contract ${contractName} deployed at ${contractAddress}`);
                    console.log(`BlockchainModel: Bytecode length: ${bytecode.length} characters`);
                    console.log(`BlockchainModel: Total contracts: ${this.contracts.length}`);
                    
                    this.publish("blockchain", "contractDeployed", { 
                        contract,
                        transaction 
                    });
                    
                } catch (error) {
                    console.error("BlockchainModel: Contract deployment failed:", error.message);
                    
                    this.publish("blockchain", "deploymentFailed", { 
                        error: error.message,
                        contractData 
                    });
                }
            }
            

            
            handleCompilationSuccess(compilationData) {
                // This method should NOT exist! 
                // External events should go through the View, not directly to the Model
                console.error("BlockchainModel: handleCompilationSuccess should not be called directly!");
            }
            
            handleCompilationError(errorData) {
                // This method should NOT exist! 
                // External events should go through the View, not directly to the Model
                console.error("BlockchainModel: handleCompilationError should not be called directly!");
            }
            
            handleCompiledContract(compilationData) {
                // Handle compiled contract that was published via Multisynq
                console.log("BlockchainModel: Processing compiled contract for deployment", compilationData);
                
                const { bytecode, abi, contractName, metadata } = compilationData;
                
                // Store compiled contract (ready for deployment)
                this.publish("contract", "readyForDeployment", { 
                    contractName,
                    bytecode,
                    abi,
                    metadata,
                    canDeploy: true,
                    timestamp: this.now()
                });
            }
            
            heartbeat() {
                // Increment heartbeat counter
                this.heartbeatCount++;
                
                // Calculate model hash for synchronization verification
                const modelState = {
                    blocks: this.blocks.length,
                    pendingTx: this.pendingTransactions.length,
                    contracts: this.contracts.length,
                    balances: this.accounts.map(acc => acc.balance.toString())
                };
                
                const modelHash = this.calculateModelHash(modelState);
                
                // Publish heartbeat with synchronization data
                this.publish("system", "heartbeat", {
                    count: this.heartbeatCount,
                    modelHash: modelHash,
                    timestamp: this.now()
                });
                
                // Schedule next heartbeat
                this.future(1000).heartbeat();
            }
            

            
            autoMineBlock() {
                // Auto-mine blocks with pending transactions (like Hello World's tick)
                if (this.pendingTransactions.length > 0) {
                    console.log(`BlockchainModel: Auto-mining block with ${this.pendingTransactions.length} pending transactions`);
                    this.createBlock();
                }
                
                // Publish blockchain status (like Hello World's tick publish)
                this.publish("blockchain", "tick", { 
                    blockNumber: this.currentBlockNumber,
                    pendingTransactions: this.pendingTransactions.length,
                    timestamp: this.now() // Use Multisynq deterministic time
                });
                
                // Schedule next auto-mine (like Hello World's future tick)
                this.future(15000).autoMineBlock();
            }
            
            // Utility methods
            generateBlockHash() {
                return "0x" + Math.random().toString(16).substr(2, 64).padStart(64, '0');
            }
            
            generateTransactionHash() {
                return "0x" + Math.random().toString(16).substr(2, 64).padStart(64, '0');
            }
            
            generateContractAddress() {
                return "0x" + Math.random().toString(16).substr(2, 40).padStart(40, '0');
            }
            
            calculateModelHash(modelState) {
                // Simple hash calculation for synchronization verification
                const stateString = JSON.stringify(modelState);
                let hash = 0;
                for (let i = 0; i < stateString.length; i++) {
                    const char = stateString.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return Math.abs(hash).toString(16).padStart(8, '0');
            }
            
            getLastBlock() {
                return this.blocks[this.blocks.length - 1];
            }
            
            // Getter methods for view access (read-only)
            getBlocks() {
                return this.blocks;
            }
            
            getAccounts() {
                return this.accounts;
            }
            
            getContracts() {
                return this.contracts;
            }
            
            getPendingTransactions() {
                return this.pendingTransactions;
            }
        }

        // Register the model (exactly like Hello World)
        BlockchainModel.register("BlockchainModel");

        // BlockchainView code (simplified for inline use)
        class BlockchainView extends Multisynq.View {
            constructor(model) {
                super(model);
                this.model = model;
                this.lastCompiledContract = null; // Store the most recent compiled contract
                
                console.log("BlockchainView: Initializing...");
                
                // Set up UI event handlers (like Hello World's onclick)
                this.setupEventHandlers();
                
                // Subscribe to model changes (like Hello World's counter changed)
                // Note: Don't use .bind() with Multisynq - pass method names as strings
                this.subscribe("blockchain", "blockAdded", "blockAdded");
                this.subscribe("blockchain", "transactionExecuted", "transactionExecuted");
                this.subscribe("blockchain", "transactionFailed", "transactionFailed");
                this.subscribe("blockchain", "contractDeployed", "contractDeployed");
                this.subscribe("blockchain", "deploymentFailed", "deploymentFailed");
                this.subscribe("blockchain", "tick", "blockchainTick");
                this.subscribe("contract", "readyForDeployment", "contractReady");
                this.subscribe("system", "heartbeat", "systemHeartbeat");
                
                // Initial display update (like Hello World's initial counterChanged call)
                this.updateDisplay();
                
                // Load existing blockchain history for new participants
                this.loadExistingBlockchainHistory();
                
                console.log("BlockchainView: Initialized and ready");
            }
            
            setupEventHandlers() {
                // Set up button event handlers
                document.getElementById('createBlockBtn').onclick = () => this.createBlock();
                document.getElementById('sendTransactionBtn').onclick = () => this.sendTransaction();
                document.getElementById('deployContractBtn').onclick = () => this.deployContract();
                document.getElementById('compileContractBtn').onclick = () => this.compileContract();
                document.getElementById('deployCompiledBtn').onclick = () => this.deployCompiledContract();
                
                // Set up compilation event listeners
                window.addEventListener('compilation-success', (event) => {
                    this.handleCompilationSuccess(event.detail);
                });
                
                window.addEventListener('compilation-error', (event) => {
                    this.handleCompilationError(event.detail);
                });
                
                window.addEventListener('compilation-started', (event) => {
                    this.handleCompilationStarted(event.detail);
                });
            }
            
            createBlock() {
                console.log("BlockchainView: User requested block creation");
                this.publish("blockchain", "createBlock");
            }
            
            sendTransaction() {
                const transactionData = {
                    from: document.getElementById('fromAccount').value,
                    to: document.getElementById('toAccount').value,
                    value: document.getElementById('transactionValue').value || "10"
                };
                
                console.log("BlockchainView: User requested transaction", transactionData);
                this.publish("blockchain", "executeTransaction", transactionData);
            }
            
            compileContract() {
                const sourceCode = document.getElementById('solidityCode').value;
                const contractName = document.getElementById('contractName').value || 'Contract';
                
                if (!sourceCode.trim()) {
                    this.showCompilationStatus('Please enter Solidity code', 'error');
                    return;
                }
                
                console.log("BlockchainView: User requested contract compilation");
                
                // Use global compilation manager to compile
                if (window.compilationManager) {
                    const requestId = window.compilationManager.requestCompilation(sourceCode, contractName);
                    console.log(`BlockchainView: Compilation requested with ID: ${requestId}`);
                } else {
                    this.showCompilationStatus('Compilation manager not available', 'error');
                }
            }
            
            deployContract() {
                const contractData = {
                    contractName: "TestContract",
                    bytecode: "0x608060405234801561001057600080fd5b50600080fd5b00",
                    abi: [],
                    from: this.model.getAccounts()[0].address
                };
                
                console.log("BlockchainView: User requested test contract deployment");
                this.publish("blockchain", "deployContract", contractData);
            }
            
            deployCompiledContract() {
                // Check if we have compiled contracts ready for deployment
                console.log("BlockchainView: Checking for compiled contracts...");
                
                // First check if we have a contract stored for deployment
                if (!this.lastCompiledContract) {
                    this.showCompilationStatus('No compiled contracts available for deployment. Please compile a contract first.', 'error');
                    return;
                }
                
                console.log("BlockchainView: Found compiled contract:", this.lastCompiledContract);
                
                const contractData = {
                    contractName: this.lastCompiledContract.contractName,
                    bytecode: this.lastCompiledContract.bytecode,
                    abi: this.lastCompiledContract.abi || [],
                    from: this.model.getAccounts()[0].address
                };
                
                console.log("BlockchainView: Deploying compiled contract:", contractData);
                this.publish("blockchain", "deployContract", contractData);
                
                // Show deployment status
                this.showCompilationStatus(`Deploying ${contractData.contractName}...`, 'info');
            }
            
            // Event handlers
            blockAdded(data) {
                console.log("BlockchainView: Block added", data);
                this.updateBlocksList(data.block);
                this.updateDisplay();
            }
            
            transactionExecuted(data) {
                console.log("BlockchainView: Transaction executed", data);
                this.updateTransactionsList(data.transaction);
                this.updateAccountBalances();
                this.updateDisplay();
            }
            
            transactionFailed(data) {
                console.log("BlockchainView: Transaction failed", data);
                this.showError(`Transaction failed: ${data.error}`);
            }
            
            deploymentFailed(data) {
                console.log("BlockchainView: Contract deployment failed", data);
                this.showCompilationStatus(`‚ùå Deployment failed: ${data.error}`, 'error');
                
                // Reset deployment button
                const deployBtn = document.getElementById('deployCompiledBtn');
                if (deployBtn && this.lastCompiledContract) {
                    deployBtn.textContent = `üöÄ Deploy ${this.lastCompiledContract.contractName}`;
                }
            }
            
            contractDeployed(data) {
                console.log("BlockchainView: Contract deployed", data);
                this.updateContractsList(data.contract);
                this.updateDisplay();
                
                // Show deployment success
                this.showCompilationStatus(`‚úÖ ${data.contract.name} deployed successfully at ${data.contract.address.substring(0, 10)}...`, 'success');
                
                // Reset deployment button
                const deployBtn = document.getElementById('deployCompiledBtn');
                if (deployBtn) {
                    deployBtn.textContent = 'üöÄ Deploy Compiled';
                }
            }
            
            contractReady(data) {
                console.log("BlockchainView: Contract ready for deployment", data);
                this.showContractReady(data.contractName);
                
                // Store the compiled contract for deployment
                this.lastCompiledContract = {
                    contractName: data.contractName,
                    bytecode: data.bytecode,
                    abi: data.abi || [],
                    metadata: data.metadata || {}
                };
                
                console.log("BlockchainView: Stored compiled contract for deployment:", this.lastCompiledContract);
                
                // Enable deployment button for compiled contracts
                const deployBtn = document.getElementById('deployCompiledBtn');
                if (deployBtn) {
                    deployBtn.disabled = false;
                    deployBtn.textContent = `üöÄ Deploy ${data.contractName}`;
                }
            }
            
            // Compilation event handlers (from CompilationManager)
            handleCompilationStarted(data) {
                console.log("BlockchainView: Compilation started", data);
                this.showCompilationStatus(`Compiling ${data.contractName}...`, 'info');
                
                // Disable compile button during compilation
                const compileBtn = document.getElementById('compileContractBtn');
                if (compileBtn) {
                    compileBtn.disabled = true;
                    compileBtn.textContent = '‚è∞ Compiling...';
                }
            }
            
            handleCompilationSuccess(data) {
                console.log("BlockchainView: Compilation successful", data);
                this.showCompilationStatus(`‚úÖ ${data.contractName} compiled successfully! Bytecode: ${data.bytecode.length} chars`, 'success');
                
                // Re-enable compile button
                const compileBtn = document.getElementById('compileContractBtn');
                if (compileBtn) {
                    compileBtn.disabled = false;
                    compileBtn.textContent = 'üî® Compile Contract';
                }
                
                // Publish compiled contract directly to Model via Multisynq
                this.publish("compilation", "complete", {
                    contractName: data.contractName,
                    bytecode: data.bytecode,
                    abi: data.abi || [],
                    metadata: data.metadata || {},
                    compiledAt: Date.now(), // External timestamp (will be processed by model)
                    success: true
                });
            }
            
            handleCompilationError(data) {
                console.log("BlockchainView: Compilation error", data);
                this.showCompilationStatus(`‚ùå Compilation failed: ${data.error}`, 'error');
                
                // Re-enable compile button
                const compileBtn = document.getElementById('compileContractBtn');
                if (compileBtn) {
                    compileBtn.disabled = false;
                    compileBtn.textContent = 'üî® Compile Contract';
                }
                
                // Publish compilation error to Model via Multisynq  
                this.publish("compilation", "error", {
                    error: data.error,
                    contractName: data.contractName || "Unknown",
                    timestamp: Date.now(), // External timestamp
                    success: false
                });
            }
            
            blockchainTick(data) {
                const tickElement = document.getElementById('blockchainTick');
                if (tickElement) {
                    // Use Multisynq time for display consistency
                    const sessionSeconds = Math.floor(data.timestamp / 1000);
                    tickElement.textContent = `‚õèÔ∏è Block: ${data.blockNumber} | ‚è∞ Pending: ${data.pendingTransactions} | ‚è±Ô∏è ${sessionSeconds}s`;
                }
            }
            
            systemHeartbeat(data) {
                // Update heartbeat counter
                const heartbeatElement = document.getElementById('heartbeatCounter');
                if (heartbeatElement) {
                    heartbeatElement.textContent = data.count.toString();
                }
                
                // Update model hash
                const hashElement = document.getElementById('modelHash');
                if (hashElement) {
                    hashElement.textContent = `Hash: ${data.modelHash}`;
                }
            }
            
            loadExistingBlockchainHistory() {
                // Load all existing blocks (including those created before this user joined)
                const existingBlocks = this.model.getBlocks();
                console.log(`BlockchainView: Loading ${existingBlocks.length} existing blocks`);
                
                existingBlocks.forEach(block => {
                    this.updateBlocksList(block);
                });
                
                // Load all existing contracts
                const existingContracts = this.model.getContracts();
                console.log(`BlockchainView: Loading ${existingContracts.length} existing contracts`);
                
                existingContracts.forEach(contract => {
                    this.updateContractsList(contract);
                });
                
                // Load all existing transactions from all blocks
                let allTransactions = [];
                existingBlocks.forEach(block => {
                    if (block.transactions && block.transactions.length > 0) {
                        allTransactions = allTransactions.concat(block.transactions);
                    }
                });
                
                console.log(`BlockchainView: Loading ${allTransactions.length} existing transactions`);
                allTransactions.forEach(transaction => {
                    this.updateTransactionsList(transaction);
                });
                
                // Update the display with current state
                this.updateDisplay();
                
                console.log("BlockchainView: Blockchain history loaded successfully");
            }
            
            // UI Update methods
            updateDisplay() {
                this.updateBlockCount();
                this.updateAccountBalances();
                this.updateContractCount();
                this.updatePendingTransactions();
            }
            
            updateBlockCount() {
                document.getElementById('blockCount').textContent = this.model.getBlocks().length;
            }
            
            updateAccountBalances() {
                const accounts = this.model.getAccounts();
                accounts.forEach((account, index) => {
                    const balanceElement = document.getElementById(`balance${index}`);
                    if (balanceElement) {
                        balanceElement.textContent = `${account.balance.toString()} ETH`;
                    }
                });
            }
            
            updateContractCount() {
                document.getElementById('contractCount').textContent = this.model.getContracts().length;
            }
            
            updatePendingTransactions() {
                document.getElementById('pendingTransactions').textContent = this.model.getPendingTransactions().length;
            }
            
            updateBlocksList(block) {
                const blocksListElement = document.getElementById('blocksList');
                const blockDiv = document.createElement('div');
                blockDiv.className = 'block-item';
                blockDiv.innerHTML = `
                    <strong>Block ${block.number}</strong><br>
                    Hash: ${block.hash.substring(0, 10)}...<br>
                    Transactions: ${block.transactions.length}<br>
                    Time: ${new Date(block.timestamp).toLocaleTimeString()}
                `;
                blocksListElement.appendChild(blockDiv);
                
                // Keep only last 10 blocks
                while (blocksListElement.children.length > 10) {
                    blocksListElement.removeChild(blocksListElement.firstChild);
                }
            }
            
            updateTransactionsList(transaction) {
                const transactionsListElement = document.getElementById('transactionsList');
                const txDiv = document.createElement('div');
                txDiv.className = 'transaction-item';
                txDiv.innerHTML = `
                    <strong>${transaction.hash.substring(0, 10)}...</strong><br>
                    From: ${transaction.from.substring(0, 10)}...<br>
                    To: ${transaction.to.substring(0, 10)}...<br>
                    Value: ${transaction.value} ETH<br>
                    Status: ${transaction.status}
                `;
                transactionsListElement.appendChild(txDiv);
                
                // Keep only last 10 transactions
                while (transactionsListElement.children.length > 10) {
                    transactionsListElement.removeChild(transactionsListElement.firstChild);
                }
            }
            
            updateContractsList(contract) {
                const contractsListElement = document.getElementById('contractsList');
                const contractDiv = document.createElement('div');
                contractDiv.className = 'contract-item';
                
                // Calculate session time for display
                const sessionSeconds = Math.floor(contract.deployedAt / 1000);
                
                contractDiv.innerHTML = `
                    <strong>${contract.name}</strong>${contract.isCompiled ? ' üî®' : ' üß™'}<br>
                    Address: ${contract.address.substring(0, 10)}...<br>
                    Deployed by: ${contract.deployedBy.substring(0, 10)}...<br>
                    Time: ${sessionSeconds}s<br>
                    Bytecode: ${contract.bytecode.length} chars
                `;
                contractsListElement.appendChild(contractDiv);
                
                // Keep only last 5 contracts
                while (contractsListElement.children.length > 5) {
                    contractsListElement.removeChild(contractsListElement.firstChild);
                }
            }
            
            showError(message) {
                const errorElement = document.getElementById('errorMessages');
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message;
                errorElement.appendChild(errorDiv);
                
                setTimeout(() => errorDiv.remove(), 5000);
            }
            
            showContractReady(contractName) {
                const messageElement = document.getElementById('statusMessages');
                const msgDiv = document.createElement('div');
                msgDiv.className = 'success-message';
                msgDiv.textContent = `Contract ${contractName} compiled and ready for deployment`;
                messageElement.appendChild(msgDiv);
                
                setTimeout(() => msgDiv.remove(), 3000);
            }
            
            showCompilationStatus(message, type) {
                const statusElement = document.getElementById('compilationStatus');
                if (!statusElement) return;
                
                statusElement.style.display = 'block';
                statusElement.textContent = message;
                
                // Set styling based on type
                switch (type) {
                    case 'success':
                        statusElement.style.backgroundColor = '#e6ffe6';
                        statusElement.style.color = '#00b894';
                        statusElement.style.border = '1px solid #00b894';
                        break;
                    case 'error':
                        statusElement.style.backgroundColor = '#ffe6e6';
                        statusElement.style.color = '#d63031';
                        statusElement.style.border = '1px solid #d63031';
                        break;
                    case 'info':
                        statusElement.style.backgroundColor = '#e6f3ff';
                        statusElement.style.color = '#0984e3';
                        statusElement.style.border = '1px solid #0984e3';
                        break;
                    default:
                        statusElement.style.backgroundColor = '#f8f9fa';
                        statusElement.style.color = '#2d3436';
                        statusElement.style.border = '1px solid #ddd';
                }
                
                // Auto-hide success and info messages
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        if (statusElement.textContent === message) {
                            statusElement.style.display = 'none';
                        }
                    }, 5000);
                }
            }
        }

        // Start the application (exactly like Hello World's Session.join)
        console.log("Starting YZ-ETH Multisynq Application...");
        
        Multisynq.Session.join({
            apiKey: "2tY4BJ0rxQ1PFm3gv0IpKYdUsQ09jnYyVb799JTULh", // Your provided API key
            appId: "com.yz-social.yz-eth-blockchain", // Unique app identifier
            name: "yz-eth-0001", // Fixed session name for easier sharing
            password: "password", // Fixed password for easier testing
            model: BlockchainModel, // Our blockchain model
            view: BlockchainView // Our blockchain view
        });
        
        console.log("YZ-ETH Multisynq Application started!");
    </script>
</body>
</html> 