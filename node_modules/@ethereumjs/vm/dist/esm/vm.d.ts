import { EventEmitter } from 'eventemitter3';
import type { Common, StateManagerInterface } from '@ethereumjs/common';
import type { EVMInterface, EVMMockBlockchainInterface } from '@ethereumjs/evm';
import type { BigIntLike } from '@ethereumjs/util';
import type { VMEvent, VMOpts } from './types.ts';
/**
 * Execution engine which can be used to run a blockchain, individual
 * blocks, individual transactions, or snippets of EVM bytecode.
 */
export declare class VM {
    /**
     * The StateManager used by the VM
     */
    readonly stateManager: StateManagerInterface;
    /**
     * The blockchain the VM operates on
     */
    readonly blockchain: EVMMockBlockchainInterface;
    readonly common: Common;
    readonly events: EventEmitter<VMEvent>;
    /**
     * The EVM used for bytecode execution
     */
    readonly evm: EVMInterface;
    protected readonly _opts: VMOpts;
    protected _isInitialized: boolean;
    protected readonly _setHardfork: boolean | BigIntLike;
    /**
     * Cached emit() function, not for public usage
     * set to public due to implementation internals
     * @hidden
     */
    readonly _emit: (topic: string, data: any) => Promise<void>;
    /**
     * VM is run in DEBUG mode (default: false)
     * Taken from DEBUG environment variable
     *
     * Safeguards on debug() calls are added for
     * performance reasons to avoid string literal evaluation
     * @hidden
     */
    readonly DEBUG: boolean;
    /**
     * Instantiates a new {@link VM} Object.
     *
     * @deprecated The direct usage of this constructor is discouraged since
     * non-finalized async initialization might lead to side effects. Please
     * use the async {@link createVM} constructor instead (same API).
     * @param opts
     */
    constructor(opts?: VMOpts);
    /**
     * Returns a copy of the {@link VM} instance.
     *
     * Note that the returned copy will share the same db as the original for the blockchain and the statemanager.
     *
     * Associated caches will be deleted and caches will be re-initialized for a more short-term focused
     * usage, being less memory intense (the statemanager caches will switch to using an ORDERED_MAP cache
     * data structure more suitable for short-term usage, the trie node LRU cache will not be activated at all).
     * To fine-tune this behavior (if the shallow-copy-returned object has a longer life span e.g.) you can set
     * the `downlevelCaches` option to `false`.
     *
     * @param downlevelCaches Downlevel (so: adopted for short-term usage) associated state caches (default: true)
     */
    shallowCopy(downlevelCaches?: boolean): Promise<VM>;
    /**
     * Return a compact error string representation of the object
     */
    errorStr(): string;
}
//# sourceMappingURL=vm.d.ts.map