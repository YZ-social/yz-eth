"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBinaryTree = createBinaryTree;
const util_1 = require("@ethereumjs/util");
const blake3_1 = require("@noble/hashes/blake3");
const binaryTree_ts_1 = require("./binaryTree.js");
const types_ts_1 = require("./types.js");
async function createBinaryTree(opts) {
    const key = (0, util_1.bytesToHex)(types_ts_1.ROOT_DB_KEY);
    // Provide sensible default options
    const parsedOptions = {
        ...opts,
        db: opts?.db ?? new util_1.MapDB(),
        useRootPersistence: opts?.useRootPersistence ?? false,
        cacheSize: opts?.cacheSize ?? 0,
        hashFunction: opts?.hashFunction ?? blake3_1.blake3,
    };
    if (parsedOptions.useRootPersistence === true) {
        if (parsedOptions.root === undefined) {
            const root = await parsedOptions.db.get(key, {
                keyEncoding: util_1.KeyEncoding.Bytes,
                valueEncoding: util_1.ValueEncoding.Bytes,
            });
            if (typeof root === 'string') {
                parsedOptions.root = (0, util_1.unprefixedHexToBytes)(root);
            }
            else {
                parsedOptions.root = root;
            }
        }
        else {
            await parsedOptions.db.put(key, parsedOptions.root, {
                keyEncoding: util_1.KeyEncoding.Bytes,
                valueEncoding: util_1.ValueEncoding.Bytes,
            });
        }
    }
    const tree = new binaryTree_ts_1.BinaryTree(parsedOptions);
    // If the root node does not exist, initialize the empty root node
    if (parsedOptions.root === undefined)
        await tree.createRootNode();
    return tree;
}
//# sourceMappingURL=constructors.js.map